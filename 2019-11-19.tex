\subsection{Quanta memoria!}\stepcounter{numex}
 Si considerino i 4 stralci di codice qua riportati: per ciascuno di essi si vuole calcolare la quantit\`a di memoria allocata per le variabili dichiarate ed utilizzate (quindi la memoria allocata nel momento in cui si arriva all'ultima istruzione del codice riportato). Si utilizzi l'operatore \texttt{sizeof}. Per i primi due stralci, il calcolo \`e gi\`a stato fatto, riportare il risultato nell'apposito spazio il calcolo per gli ultimi due stralci.

\small
\begin{tabular}{p{2.5cm}p{3.8cm}p{6.5cm}p{4.2cm}}
\begin{lstlisting}[language=c, tabsize=1]
int a;
...
scanf("%d", &a);
\end{lstlisting} &
\begin{lstlisting}[language=c, tabsize=1]
int v[NUM], i;
...
for(i = 0; i < NUM; i++)
	scanf("%d", &v[i]);
\end{lstlisting} &
\begin{lstlisting}[language=c, tabsize=1]
int * p, i, ndati;
...
if(p = (int *)malloc(ndati*sizeof(int))){
	for (i = 0; i < ndati; i++)
		scanf("%d", p+i);
...
\end{lstlisting} &
\begin{lstlisting}[language=c, tabsize=1]
typedef struct _s {
	int val;
	struct _s * next;
} t_listi;
...
t_listi * head = NULL;
int i, n, ndati;
...
ndati = 0;
scanf("%d", &n);
while(n != STOP){
	head = append(head, n);
	ndati++;
	scanf("%d", &n);
}

\end{lstlisting} \\
\multicolumn{4}{l}{quantit\`a di memoria complessiva allocata:}\\
\begin{lstlisting}[language=c, tabsize=1]
sizeof(int)
 
.
\end{lstlisting}
& \begin{lstlisting}[language=c, tabsize=1]
NUM * sizeof(int) + 
sizeof(int)
.
\end{lstlisting} & 
\begin{lstlisting}[language=c, tabsize=1]


.
\end{lstlisting} & 
\begin{lstlisting}[language=c, tabsize=1]


.
\end{lstlisting} \\
\end{tabular}

\subsection{Insieme unione}\stepcounter{numex}
Scrivere un sottoprogramma che ricevute in ingresso due liste che rappresentano insiemi di valori interi, restituisce una nuova lista rappresentante l'unione dei due insiemi.

\begin{tags}
\texttt{Unione di insiemi}\index{Programmi lista concatenata semplice!Unione di insiemi}. 
\texttt{find}\index{Lista concatenata semplice!\texttt{find}}.
\end{tags}

\getsol{srccode/list.setunion.sub.c}

\subsection{Elimina doppioni adiacenti}\stepcounter{numex}
Scrivere un sottoprogramma che ricevuta in ingresso una lista elimina dalla lista le ripetizioni di elementi \textit{adiacenti}. 

\begin{tags}
lista concatenata semplice\index{Lista concatenata semplice}. 
\texttt{deleteptr}\index{Lista concatenata semplice!\texttt{deleteptr}}.
\end{tags}


Per esempio, se la lista in ingresso \`e quella di seguito riportata e \texttt{start} \`e 1:
$$
3 \rightarrow 5 \rightarrow 1 \rightarrow 2  \rightarrow 2 \rightarrow 1 \rightarrow|
$$ 

il sottoprogramma restituisce la lista seguente

$$
3 \rightarrow 5 \rightarrow 1 \rightarrow 2 \rightarrow 1 \rightarrow|
$$ 


\getsol{srccode/list.removedup.sub.c}

\subsection{Da lista a insieme}\stepcounter{numex}
Scrivere un sottoprogramma che ricevuta in ingresso una lista la manipola facendola diventare un insieme (elimina gli elementi ripetuti). 

\begin{tags}
lista concatenata semplice\index{Lista concatenata semplice}. 
\end{tags}


Per esempio, se la lista in ingresso \`e quella di seguito riportata e \texttt{start} \`e 1:
$$
3 \rightarrow 5 \rightarrow 1 \rightarrow 2  \rightarrow 2 \rightarrow 1 \rightarrow|
$$ 

il sottoprogramma restituisce la lista seguente

$$
3 \rightarrow 5 \rightarrow 1 \rightarrow 2 \rightarrow|
$$ 


\getsol{srccode/list.removedup.sub.c}

\subsection{Riempi lista}\stepcounter{numex}
Scrivere un sottoprogramma che ricevuto in ingresso un valore intero \texttt{num} crea una lista chiedendo all'utente \texttt{num} valori interi e la restituisce all'utente. Anche se sappiamo quanti dati vogliamo memorizzare (e quindi una unica istruzione \texttt{malloc} sarebbe appropriata) lo scopo \`e creare una lista da usare per collaudare gli altri sottoprogrammi.

\begin{tags}
lista concatenata semplice\index{Lista concatenata semplice}. 
\texttt{fill}\index{Lista concatenata semplice!\texttt{fill}}.
\end{tags}

\getsol{srccode/list.fill.sub.c}