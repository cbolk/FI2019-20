\subsection{Quanta memoria!}\stepcounter{numex}
 Si considerino i 4 stralci di codice qua riportati: per ciascuno di essi si vuole calcolare la quantit\`a di memoria allocata per le variabili dichiarate ed utilizzate (quindi la memoria allocata nel momento in cui si arriva all'ultima istruzione del codice riportato). Si utilizzi l'operatore \texttt{sizeof}. Per i primi due stralci, il calcolo \`e gi\`a stato fatto, riportare il risultato nell'apposito spazio il calcolo per gli ultimi due stralci.

\small
\begin{tabular}{p{2.5cm}p{3.8cm}p{6.5cm}p{4.2cm}}
\begin{lstlisting}[language=c, tabsize=1]
int a;
...
scanf("%d", &a);
\end{lstlisting} &
\begin{lstlisting}[language=c, tabsize=1]
int v[NUM], i;
...
for(i = 0; i < NUM; i++)
	scanf("%d", &v[i]);
\end{lstlisting} &
\begin{lstlisting}[language=c, tabsize=1]
int * p, i, ndati;
...
if(p = (int *)malloc(ndati*sizeof(int))){
	for (i = 0; i < ndati; i++)
		scanf("%d", p+i);
...
\end{lstlisting} &
\begin{lstlisting}[language=c, tabsize=1]
typedef struct _s {
	int val;
	struct _s * next;
} t_listi;
...
t_listi * head = NULL;
int i, n, ndati;
...
ndati = 0;
scanf("%d", &n);
while(n != STOP){
	head = append(head, n);
	ndati++;
	scanf("%d", &n);
}

\end{lstlisting} \\
\multicolumn{4}{l}{quantit\`a di memoria complessiva allocata:}\\
\begin{lstlisting}[language=c, tabsize=1]
sizeof(int)
 
.
\end{lstlisting}
& \begin{lstlisting}[language=c, tabsize=1]
NUM * sizeof(int) + 
sizeof(int)
.
\end{lstlisting} & 
\begin{lstlisting}[language=c, tabsize=1]


.
\end{lstlisting} & 
\begin{lstlisting}[language=c, tabsize=1]


.
\end{lstlisting} \\
\end{tabular}

\subsection{Insieme unione}\stepcounter{numex}
Scrivere un sottoprogramma che ricevute in ingresso due liste che rappresentano insiemi di valori interi, restituisce una nuova lista rappresentante l'unione dei due insiemi.

\begin{tags}
\texttt{Unione di insiemi}\index{Programmi lista concatenata semplice!Unione di insiemi}. 
\texttt{find}\index{Lista concatenata semplice!\texttt{find}}.
\end{tags}

\getsol{srccode/list.setunion.sub.c}

\subsection{Elimina doppioni adiacenti}\stepcounter{numex}
Scrivere un sottoprogramma che ricevuta in ingresso una lista elimina dalla lista le ripetizioni di elementi \textit{adiacenti}. 

\begin{tags}
lista concatenata semplice\index{lista concatenata semplice}. 
\texttt{deleteptr}\index{Lista concatenata semplice!\texttt{deleteptr}}.
\end{tags}


Per esempio, se la lista in ingresso \`e quella di seguito riportata e \texttt{start} \`e 1:
$$
3 \rightarrow 5 \rightarrow 1 \rightarrow 2  \rightarrow 2 \rightarrow 1 \rightarrow|
$$ 

il sottoprogramma restituisce la lista seguente

$$
3 \rightarrow 5 \rightarrow 1 \rightarrow 2 \rightarrow 1 \rightarrow|
$$ 


\getsol{srccode/list.removedup.sub.c}

\subsection{Da lista a insieme}\stepcounter{numex}
Scrivere un sottoprogramma che ricevuta in ingresso una lista la manipola facendola diventare un insieme (elimina gli elementi ripetuti). 

\begin{tags}
lista concatenata semplice\index{lista concatenata semplice}. 
\end{tags}


Per esempio, se la lista in ingresso \`e quella di seguito riportata e \texttt{start} \`e 1:
$$
3 \rightarrow 5 \rightarrow 1 \rightarrow 2  \rightarrow 2 \rightarrow 1 \rightarrow|
$$ 

il sottoprogramma restituisce la lista seguente

$$
3 \rightarrow 5 \rightarrow 1 \rightarrow 2 \rightarrow|
$$ 


\getsol{srccode/list.removedup.sub.c}


\subsection{Scompatta lista}\stepcounter{numex}
Scrivere un sottoprogramma \texttt{extract} che riceve in ingresso una lista per la gestione dei numeri interi, e un intero \texttt{start} che vale senz'altro o 0 o 1 (non \`e necessario gestire il caso in cui non sia cos\`i). La lista \textit{codifica} un'informazione binaria: il valore del primo elemento indica quante volte consecutive compare il bit \texttt{start}, il secondo elemento indica quante volte compare il complemento di \texttt{start}, il terzo elemento quante volte compare il bit  \texttt{start} e cos\`i fino alla fine.
Il sottoprogramma scompatta tale informazione e restituisce \textbf{una nuova lista} i cui elementi contengono ciascuno 0 o 1. 

Non \`e necessario definire due tipi diversi di dato, poich\`e il contenuto dell'elemento della lista \`e comunque sempre un intero. 

Per esempio, se la lista in ingresso \`e quella di seguito riportata e \texttt{start} \`e 1:
$$
3 \rightarrow 5 \rightarrow 1 \rightarrow 2  \rightarrow 2 \rightarrow 1 \rightarrow|
$$ 

il sottoprogramma restituisce la lista seguente

$$
1 \rightarrow 1 \rightarrow 1 \rightarrow 0 \rightarrow 0 \rightarrow 0 \rightarrow 0 \rightarrow 0 \rightarrow 1 \rightarrow 0 \rightarrow 0 \rightarrow 1 \rightarrow 1 \rightarrow 0 \rightarrow|
$$ 

\begin{tags}
lista concatenata semplice\index{lista concatenata semplice}. 
\end{tags}

\begin{esame}
09/09/2019
\end{esame}


\getsol{srccode/20190909.liste.c}


\subsection{Valori sotto la media}\stepcounter{numex}
Scrivere un sottoprogramma che riceve in ingresso un array di valori interi e qualsiasi altro parametro ritenuto strettamente necessario e restituisce una lista contenente tutti e soli i valori dell'array che sono minori o uguali alla media dei valori contenuti nell'array stesso.

\begin{tags}
ista concatenata semplice. algoritmo. calcolo della media dei valori.
\end{tags}

\begin{esame}
04/09/2015
\end{esame}

\getsol{srccode/listbelowavg.sub.c}

 