\subsection{Array to list}\stepcounter{numex}
Scrivere un sottoprogramma che riceve in ingresso un array di valori interi e qualsiasi altro parametro ritenuto strettamente necessario e restituisce una lista contenente tutti e soli i valori dell'array che sono minori o uguali alla media dei valori contenuti nell'array stesso.

\begin{tags}
array. liste. calcolo media.
\end{tags}
\getsol{srccode/arraytolist.c}


\subsection{Convoluzione 1D}\stepcounter{numex}
Si vuole riprodurre l'operazione di convoluzione discreta a una dimensione.
In pratica si tratta di applicare un array monodimensionale chiamato filtro o kernel a un altro array monodimensionale.
Il risultato della convoluzione \`e, per ogni cella \texttt{i}, l'applicazione del filtro a partire dalla cella \texttt{i} dell'array di partenza.
Per applicazione si intende la somma della moltiplicazione elemento per elemento tra gli elementi dell'array e gli elementi del filtro.

Un esempio:

\begin{verbatim}
Array: 1 2 3 4 5 6
Filtro: 1 0 1
Risultato: 4 6 8 10
\end{verbatim}
Infatti, $4 = 1*1 + 2*0 + 3*1, 6=2*1 + 3*0 + 4*1, 8 = 3*1 + 4*0 + 5*1, 10 = 4*1 + 5*0 + 6*1$.
Da notare che l'applicazione del filtro viene fatta solamente se \`e possibile applicare l'intero filtro, e non solo una sua parte. 
Se non \`e pi\`u possibile applicare l'intero filtro, la convoluzione termina.
\\
Scrivere un programma che chiede in ingresso il nome di un file (di lunghezza massima 50 caratteri).
Il file contiene, nella prima riga, due interi, rispettivamente la dimensione dell'array \texttt{n} e la dimensione del filtro \texttt{k}, con sicuramente $\texttt{n} \geq \texttt{k}$.
La seconda riga contiene \texttt{n} interi, che rappresentano i valori dell'array.
La terza ed ultima riga contiene \texttt{k} interi, che rappresentano i valori del filtro.
Il programma legge il file avente il formato appena proposto e applica il filtro all'array, salva il risultato in un nuovo array e ne stampa il contenuto.

\begin{tags}
allocazione dinamica. file.
\end{tags}

\getsol{srccode/convoluzione.c}

\subsection{Accesso utente banca}\stepcounter{numex}

Si vuole gestire l'accesso ai dati relativi ai conti correnti dei clienti di una banca.
La banca in questione \`e minimalista e per ogni utente memorizza solamente il nome utente e la password per l'accesso al conto e il saldo attuale.
Si definisca un nuovo tipo di dato per memorizzare queste informazioni, sapendo che nome utente e password sono lunghi al pi\`u 50 caratteri.

Si scriva quindi un sottoprogramma che dati in ingresso l'array degli utenti, un nome utente, una password e tutti i parametri ritenuti necessari, cerchi l'utente nell'array che corrisponda alle credenziali (nome utente e password) ricevute in ingresso e, se esiste, ne restituisca la posizione all'interno dell'array, altrimenti restituisca -1.

\begin{tags}
stringhe. \texttt{typedef}.
\end{tags}

\getsol{srccode/elenco-utenti.c}

\subsection{Vicinanza media di una matrice}\stepcounter{numex}

Scrivere un sottoprogramma che data in ingresso una matrice di numeri reali e tutti i parametri strettamente necessari, trasmette la media dei valori della matrice e la posizione (in termini di indici di riga e colonna) della cella il cui valore \`e il pi\`u vicino alla media.
Come precisazione, per \textit{vicinanza} tra due numeri si intende il valore assoluto della loro differenza.
In caso ci fossero pi\`u valori con minima vicinanza alla media, selezionarne uno a piacere.

Scrivere quindi un programma che dati in ingresso due interi, rispettivamente il numero di righe e il numero di colonne (che si assumono validi e inseriti correttamente), e una matrice di reali di quelle dimensioni, ne calcola e stampa la media dei valori, il valore pi\`u vicino alla media e la sua posizione.
Si assuma che la matrice abbia al massimo 20 righe e 20 colonne.
E' consentito scrivere ulteriori sottoprogrammi di supporto per operazioni ripetute, se ritenuto necessario.

\begin{tags}
array bidimensionale. passaggio parametri per indirizzo.
\end{tags}

\getsol{srccode/vicinanza-media.c}


\subsection{Separa stringa (proposto)}\stepcounter{numex}

Scrivere un sottoprogramma che, data in ingresso una stringa, separa la stringa in concomitanza degli spazi e restituisce una lista contenente i pezzi della stringa separata, nell'ordine in cui sono presenti nella stringa originale.
Esempio: 
\begin{verbatim}
"Questa stringa deve  essere separata ! "
\end{verbatim}

$\texttt{"Questa"} \rightarrow \texttt{"stringa"} \rightarrow \texttt{"deve"} \rightarrow \texttt{"essere"} \rightarrow \texttt{"separata"} \rightarrow \texttt{"!"} \rightarrow \texttt{|}$


Da notare che ci possono essere pi\`u spazi tra una parola e l'altra, in tal caso devono essere considerati come un unico spazio.

Si dispone del seguente tipo di lista e si considerino gi\`a disponibili (e quindi non da sviluppare) i sottoprogrammi seguenti:

\begin{lstlisting}[language=c]
typedef struct slist_s{

    char * str;
    struct slist_s * next;
    
} slist_t;


/*inserisce in testa alla lista*/
slist_t * push(slist_t *, char *);

/*inserisce in coda alla lista*/
slist_t * append(slist_t *, char *);
\end{lstlisting}

\begin{tags}
liste. stringhe. allocazione dinamica.
\end{tags}

\getsol{srccode/separa-stringa.c}

